import escape from './lib/escape';
import versionCompare from './lib/version-compare';
import arrayChunk from './lib/array-chunk';

export default {
  /**
   * 只支持 2 层拷贝，特殊合并后返回的新对象
   * 
   * @param { Object } cloneTarget 被拷贝对象， 2 层嵌套
   * @param { Object } mergeSource 被合并对象，2 层嵌套（mergeSource 一级只会合并 cloneTarget 已知的一级，2 级全部合并）
   * @returns { Object } 拷贝合并后的新对象
   */
  cloneMerge: function(cloneTarget, mergeSource) {
    let obj = {};
    Object.keys(cloneTarget).forEach((key) => {
      obj[key] = Object.assign({}, cloneTarget[key], mergeSource[key]);
    });
    return obj;
  },
  /**
   * 用于兼容tce数据和本地mock数据返回不同类型的true
   */
  isTrue: function(val) {
    return val === 'true' || val === true;
  },
  /**
   * 用于兼容tce数据，本地mock数据以及投放系统返回不同类型的true
   */
  isTrueForTF: function(val) {
    return val === 'true' || val === '1' || val === true;
  },
  buffer: function(fn, ms, context) {
    ms = ms || 150;

    if (ms === -1) {
      return function() {
        fn.apply(context || this, arguments);
      };
    }
    var bufferTimer = null;

    function f() {
      f.stop();
      const arg = arguments;
      const self = this;
      bufferTimer = setTimeout(function() {
        fn.apply(context || self, arg);
      }, ms);
    }

    f.stop = function() {
      if (bufferTimer) {
        clearTimeout(bufferTimer);
        bufferTimer = 0;
      }
    };

    return f;
  },
  unEscapeHTML: escape.unEscapeHTML,
  versionCompare,
  arrayChunk
};